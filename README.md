High-Level approach:
My approach to this project was to first get the input from the user off of the command line and figuring out how many arguements are given and which arguements represent what(i.e. which is the url and which is the local arguement). Then I set all the messages that were going to be static to a variable for ease of use and to avoid misstyping the messages. Then I parsed the url to get the information I would need for the rest of the protocol(the username, password, hostname, port, and path). After this, I proceeded with an initializing stream of commands to the server in order to set up the environment specified in the protocol of the project. After this, I then go into the cascading if statements to find which operation was given in the command line and execute it. Generally speaking, to execute the commands that did not require a data channel, simply the command was sent(mkdir, rmdir, and rm). To execute ls, the PASV command was sent and the message recieved from doing so was parsed into the ip address and port number that were embedded within. Then, the LIST command was sent and a secure TLS connection was made with the provided ip and port. Once this was connectoin was established, the information created by the LIST command was recieved and printed to the terminal and the secure connection was closed. In the case of copy, the code does slighlty different things depending on if the url was given first or second in the input of parameters following the operation. Either way, the program starts by sending a PASV command and parsing the recieved message for the ip and port to use to create a secure connection with the server. Then, if the url was given first, the code opens a file, copies the contents of the file on the server into it, then closes the new file and the connection to the server. If the url was second, it copies the contents of the file on the users machine and copies it to a file on the server. For mv, my program mostly does the same thing as cp and rm. If the url was the first parameter, the program sends the PASV command and sets up a secure connection in order to send the contents of the specified file and write them into a new local file, it then closes this channel and the file. After this, it sends a command to delete the file from the server, completing the "move" of the file. If the url is the second parameter, the PASV command is sent the ip and port for the secure connection are parsed out of the recieved message from the server. A secure connection is then made and the contents of the local file are sent to the server, the file is then closed and the secure connection channel is closed. The local file is then delted, completing the "move" of the file. Once the program is finished running the given operation, a QUIT command is sent to the server, closing the connection and finishing the programs protocol. 

Challenges:
A major challenge I faced was that I could not figure out why the line, secure_s = context.wrap_socket(data_connection_socket, server_hostname=hostname), was giving me an issue. Despite trying to debug it for many hours, I could not figure out why it did not seem to get past this line despite this exact call and the setup before it working on every other part of the program. As a result when trying to mv something from the local host to the server, currently this does not work and a force quit using command c is needed.

Testing:
In order to test the program, multiple print statements were used throughout the implementation of the code in order to read the servers output statements, check that variables were being created with expected values, and many print statements that are no longer seen were used in debugging. I also manually ran each command in order to see that they were doing what I expected them too. 
